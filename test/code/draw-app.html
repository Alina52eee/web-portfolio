<!--
 Функция:
  - Холст для рисования.
  - Размер и цвет кисти.
  - Заливка.
  - Очистка листа.
  - Сохронение рисунка.
  
 Новые функции:
  - Заливка как отдельный инструмент.
  - Заливка замкнутых фигур.
  - Инструмент ластик.
  - шаг назад.
  - шаг вперёд для исправления.
-->
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Рисовальщик с заливкой, ластиком и историями</title>
<style>
  body { display: flex; flex-direction: column; align-items: center; font-family: Arial; }
  #canvas { border: 1px solid #000; cursor: crosshair; }
  .controls { margin: 10px; }
  button { margin-left: 5px; }
</style>
</head>
<body>

<div class="controls">
  <label>Цвет кисти: <input type="color" id="colorPicker" value="#000000" /></label>
  <label>Размер кисти: <input type="range" id="sizePicker" min="1" max="30" value="5" /></label>
  <button id="brushBtn">Кисть</button>
  <button id="fillBtn">Заливка</button>
  <button id="eraserBtn">Ластик</button>
  <button id="undoBtn">Шаг назад</button>
  <button id="redoBtn">Шаг вперёд</button>
  <button id="clearBtn">Очистить</button>
  <button id="saveBtn">Сохранить</button>
</div>

<canvas id="canvas" width="600" height="400"></canvas>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  let painting = false;
  let brushColor = document.getElementById('colorPicker').value;
  let brushSize = document.getElementById('sizePicker').value;
  let tool = 'brush'; // brush, fill, eraser

  // История для undo/redo
  const history = [];
  let historyStep = -1;

  function saveState() {
    // Сохраняем текущее состояние холста в историю
    if (historyStep < history.length - 1) {
      history.splice(historyStep+1);
    }
    history.push(canvas.toDataURL());
    historyStep++;
  }

  function restoreState(step) {
    const img = new Image();
    img.src = history[step];
    img.onload = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
    }
  }
  
  // Изначальное состояние
  saveState();

  // Рисование кистью и ластиком
  canvas.addEventListener('mousedown', (e) => {
    if (tool === 'fill') {
      floodFill(e.offsetX, e.offsetY, brushColor);
      saveState();
      return;
    }
    painting = true;
    ctx.beginPath();
    ctx.moveTo(e.offsetX, e.offsetY);
  });

  canvas.addEventListener('mouseup', () => {
    if (painting) {
      painting = false;
      saveState();
      ctx.beginPath();
    }
  });

  canvas.addEventListener('mouseout', () => {
    painting = false;
    ctx.beginPath();
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!painting) return;
    ctx.lineCap = 'round';
    ctx.lineWidth = brushSize;
    ctx.strokeStyle = (tool === 'eraser') ? '#ffffff' : brushColor;
    ctx.lineTo(e.offsetX, e.offsetY);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(e.offsetX, e.offsetY);
  });

  document.getElementById('colorPicker').addEventListener('change', (e) => {
    brushColor = e.target.value;
  });

  document.getElementById('sizePicker').addEventListener('input', (e) => {
    brushSize = e.target.value;
  });

  // Выбор инструментов
  document.getElementById('brushBtn').addEventListener('click', () => {
    tool = 'brush';
    canvas.style.cursor = 'crosshair';
  });
  document.getElementById('fillBtn').addEventListener('click', () => {
    tool = 'fill';
    canvas.style.cursor = 'pointer';
  });
  document.getElementById('eraserBtn').addEventListener('click', () => {
    tool = 'eraser';
    canvas.style.cursor = 'crosshair';
  });

  // Очистка холста
  document.getElementById('clearBtn').addEventListener('click', () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    saveState();
  });

  // Undo
  document.getElementById('undoBtn').addEventListener('click', () => {
    if (historyStep > 0) {
      historyStep--;
      restoreState(historyStep);
    }
  });

  // Redo
  document.getElementById('redoBtn').addEventListener('click', () => {
    if (historyStep < history.length - 1) {
      historyStep++;
      restoreState(historyStep);
    }
  });

  // Сохранение
  document.getElementById('saveBtn').addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = 'drawing.png';
    link.href = canvas.toDataURL();
    link.click();
  });

  // Алгоритм заливки (flood fill)
  function floodFill(startX, startY, fillColor) {
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imgData.data;
    const width = canvas.width;
    const height = canvas.height;
    
    // Получить цвет пикселя
    function getPixelColor(x, y) {
      const idx = (y * width + x) * 4;
      return [data[idx], data[idx+1], data[idx+2], data[idx+3]];
    }
    
    // Проверка равенства цветов
    function colorsMatch(c1, c2) {
      return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
    }
    
    // Задать цвет пикселя
    function setPixelColor(x, y, color) {
      const idx = (y * width + x) * 4;
      data[idx] = color[0];
      data[idx+1] = color[1];
      data[idx+2] = color[2];
      data[idx+3] = color[3];
    }

    // Конверт цвета #rrggbb в rgba
    function hexToRgba(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255, 255];
    }

    const startColor = getPixelColor(startX, startY);
    const fillColorRGBA = hexToRgba(fillColor);

    if (colorsMatch(startColor, fillColorRGBA)) return; // если цвет совпадает, ничего не делаем

    const stack = [[startX, startY]];
    
    while (stack.length) {
      const [x, y] = stack.pop();
      const currentColor = getPixelColor(x, y);

      if (colorsMatch(currentColor, startColor)) {
        setPixelColor(x, y, fillColorRGBA);
        if (x > 0) stack.push([x - 1, y]);
        if (x < width - 1) stack.push([x + 1, y]);
        if (y > 0) stack.push([x, y - 1]);
        if (y < height - 1) stack.push([x, y + 1]);
      }
    }
    ctx.putImageData(imgData, 0, 0);
  }
</script>

</body>
</html>
